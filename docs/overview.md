# Whoosh

Whoosh — это чисто Python-библиотека для полнотекстового поиска и индексирования. Она предоставляет инструменты для создания поисковых движков прямо в вашем приложении без необходимости настраивать отдельную базу данных или сервер (например, Elasticsearch или Solr). Whoosh спроектирована как быстрая, расширяемая и простая в использовании замена подобным системам, работающая на чистом Python.

---

## Модуль 1. Контекст и предпосылки

### 1. Ограничения стандартных средств
Стандартные средства Python не имеют встроенных возможностей для полнотекстового поиска. Чтобы найти слово в списке строк, разработчику приходится использовать простой перебор (`if word in string`) или регулярные выражения. Такой подход не масштабируется:
1. **Скорость:** При росте объема данных линейный поиск становится катастрофически медленным.
2. **Ранжирование:** Нет механизмов для оценки релевантности результатов (какой документ подходит лучше).
3. **Морфология:** Не поддерживается поиск словоформ (например, поиск "стол" не найдет "столик").
4. **Сложные запросы:** Нельзя легко комбинировать условия (И/ИЛИ), искать по фразе или в определенном поле.

### 2. Проблема, которую решает инструмент
Whoosh решает проблему внедрения качественного поиска в Python-приложения, когда использование внешних тяжеловесных решений (как Elasticsearch) избыточно или невозможно. Он закрывает потребность в создании индексов и быстром поиске по тексту на стороне клиента или в небольшом проекте, где важна простота развертывания (нет зависимости от Java или внешних процессов).

### 3. Инженерная грамотность
Использование Whoosh меняет подход инженера к работе с неструктурированным текстом. Разработчик начинает мыслить категориями **индексации**, **токенизации** и **стемминга** (приведения слов к основе). Понимание того, как текст разбивается на термины и как строится обратный индекс, позволяет проектировать более умные функции поиска и автодополнения, закладывая архитектуру обработки текста на этапе проектирования, а не пытаясь "вытянуть" данные линейным перебором постфактум.

### 4. Применение в реальных проектах
- **Статические сайты и блоги:** Для поиска по статьям (например, в генераторах статических сайтов).
- **Документация:** Внутренний поиск по технической документации, вики или базам знаний.
- **Десктопные приложения:** Локальный поиск по заметкам, почте или файлам пользователя.
- **Образовательные проекты:** Изучение принципов работы поисковых движков благодаря чистой и понятной кодовой базе на Python.
- **Прототипирование:** Быстрое создание прототипа MVP (минимально жизнеспособного продукта) с поиском, который позже можно заменить на масштабируемое решение.

---

## Модуль 2. Основные идеи и механизмы

### 5. Центральные объекты и архитектура
Архитектура Whoosh строится вокруг нескольких ключевых сущностей:

1. **Schema (Схема):** Определяет поля документа (например, `title`, `content`, `path`), их тип (`TEXT`, `ID`, `KEYWORD`, `NUMERIC`) и способ индексации/хранения. Это каркас будущего индекса.
2. **Index (Индекс):** Само хранилище индексов, созданное на основе схемы. Хранится в директории на диске (или в памяти).
3. **IndexWriter (Писатель):** Объект, используемый для добавления, обновления или удаления документов из индекса. Работает как транзакция: изменения применяются только после вызова `commit()`.
4. **IndexReader (Читатель):** Объект для чтения данных из индекса (например, для получения списка терминов).
5. **Searcher (Искатель):** Объект для выполнения поисковых запросов по индексу. Возвращает объект `Results`, содержащий найденные документы и оценку их релевантности.
6. **Query (Запрос):** Объект, представляющий поисковый запрос (создается парсером или вручную).

### 6. Ключевые механизмы работы
Работа с Whoosh проходит по стандартному циклу: определение схемы -> индексация данных -> поиск.

```python
from whoosh.index import create_in
from whoosh.fields import Schema, TEXT, ID
from whoosh.qparser import QueryParser
import os

# 1. Определение схемы
schema = Schema(path=ID(unique=True, stored=True), content=TEXT(stored=True))

# 2. Создание индекса в папке "indexdir"
if not os.path.exists("indexdir"):
    os.mkdir("indexdir")
ix = create_in("indexdir", schema)

# 3. Индексация документов
writer = ix.writer()
writer.add_document(path="/wiki/лазер", content="Лазер — это устройство...")
writer.add_document(path="/wiki/мазер", content="Мазер — квантовый генератор...")
writer.commit()

# 4. Поиск
with ix.searcher() as searcher:
    query = QueryParser("content", ix.schema).parse("квантовый генератор")
    results = searcher.search(query)
    for hit in results:
        print(hit['path'], hit.score) # /wiki/мазер ...

### 7. Работа со структурированными данными
Несмотря на то, что Whoosh ориентирован на текст, он прекрасно работает со структурированными данными благодаря системе полей.

- **Мультиполевый поиск:** Можно искать одновременно по заголовку и содержимому с разным весом (бустингом). Например, заголовок может иметь больший вес при ранжировании.
- **Фасетный поиск:** Поля типа `KEYWORD` (ключевые слова) позволяют легко организовывать фильтрацию и фасеты (категории) для уточнения поисковой выдачи.
- **Числовые диапазоны:** Поля `NUMERIC` позволяют искать товары в ценовом диапазоне или статьи по дате публикации, комбинируя это с текстовым поиском.
- **Хранение и извлечение:** Поля с атрибутом `stored=True` сохраняют исходное значение, которое можно вернуть в результатах поиска (например, путь к файлу или заголовок), не обращаясь к исходной базе данных.

---

### 8. Интерактивность / автоматизация
Whoosh хорошо подходит для создания интерактивных функций поиска:

- **Поиск по мере ввода (autocomplete):** Используя механизмы `NGRAM` или `NGRAMWORDS` в схеме, можно индексировать фрагменты слов, чтобы быстро находить варианты при частичном вводе.

  ```python
  from whoosh.fields import NGRAMWORD, Schema

  schema = Schema(title=NGRAMWORD(minsize=2, maxsize=4, stored=True))
  # Теперь поиск по фрагменту "ла" найдет "лазер"
  ```

- **"Правильно ли я понял?" (Did you mean):** Whoosh может анализировать частоту терминов в индексе и предлагать исправления для слов с опечатками, используя `whoosh.spelling.SpellChecker`.
- **Автоматическое обновление индекса:** При добавлении новых данных в приложение можно программно запускать `writer.update_document()` для актуализации поискового индекса в реальном времени.
- **Фасетная навигация:** Автоматическое построение категорий на основе результатов поиска для уточнения запроса пользователем.

---

### 9. Ошибки и отладка
Будучи чисто Python-библиотекой, Whoosh предоставляет довольно прозрачный процесс отладки:

- **Подробные исключения:** Ошибки часто связаны с несоответствием схемы (попытка добавить поле, не описанное в схеме) или проблемами с парсингом запроса. Например, `whoosh.reading.TermNotFound` возникает при обращении к несуществующему термину.
- **Логирование:** Библиотека использует стандартный модуль `logging`, что позволяет включить отладку и увидеть, как именно разбирается запрос и какие термины ищутся.

  ```python
  import logging
  logging.basicConfig(level=logging.DEBUG)
  ```

- **Экспорт индекса:** Можно написать простой скрипт с `IndexReader`, чтобы посмотреть, какие термины на самом деле хранятся в индексе для конкретного поля, что помогает отладить проблемы с токенизацией и стеммингом.
- **Анализ запросов:** Метод `query.__str__()` показывает внутреннее представление запроса, что помогает понять, как парсер интерпретировал введенную строку.

---

### 10. Организация результата
Whoosh уделяет большое внимание качеству и организации выдачи:

- **Ранжирование (Scoring):** По умолчанию используется алгоритм **BM25F** (вариант Okapi BM25), который считается одним из лучших для оценки релевантности текста. Результаты сортируются по убыванию релевантности. Можно подключать собственные функции ранжирования.
- **Сниппеты (Highlighting):** Встроенные функции позволяют генерировать фрагменты текста с подсветкой найденных слов, используя HTML-теги или кастомные обертки.

  ```python
  # results - это объект Results из предыдущего примера
  for hit in results:
      print(hit['path'])
      # Создание сниппета для поля 'content'
      print(hit.highlights("content", top=3)) 
      # Выведет: ... <b class="match term0">квантовый</b> <b class="match term1">генератор</b> ...
  ```

- **Пагинация и срезы:** Результаты поддерживают срезы Python (`results[10:20]`) для простой пагинации без повторного выполнения запроса к индексу.
- **Сортировка:** Возможность сортировки результатов по произвольным полям (например, по дате или цене) с помощью параметра `sortedby` в методе `search()`.
- **Группировка и коллапсинг:** Возможность группировать результаты по полю (например, показывать только один документ от каждого автора).

---

## Модуль 3. Анализ и оценка Whoosh

### 11. Сильные стороны

- **Чистый Python:** Не требует компиляции и наличия зависимостей на C или Java. Устанавливается одной командой `pip` и работает везде, где есть Python (Windows, Linux, macOS).

- **Простота использования:** API интуитивно понятен и хорошо документирован. Для создания простого поиска нужно написать всего несколько строк кода. Кривая обучения очень пологая.

- **Гибкость и расширяемость:** Легко кастомизировать анализаторы текста (стеммеры для разных языков, фильтры стоп-слов), создавать свои типы полей и подключать собственные алгоритмы ранжирования.

- **Отсутствие сервера:** Работает как библиотека внутри вашего процесса, что упрощает развертывание и масштабирование (вертикальное) приложения. Нет необходимости настраивать и поддерживать отдельный сервис.

- **Кроссплатформенность:** Гарантированно работает на любой платформе, поддерживающей Python, без дополнительных настроек.

- **Поддержка русского языка:** Благодаря системе анализаторов можно легко подключить стеммер для русского языка (например, через `whoosh.lang.stemmers` или обертку для Snowball stemmer).

### 12. Ограничения и недостатки

- **Производительность на больших объемах:** Как чисто Python-решение, Whoosh значительно уступает в скорости и эффективности использования памяти компилируемым движкам (Lucene, на котором основан Elasticsearch) при работе с миллионами документов. Для больших проектов это может стать узким местом.

- **Отсутствие распределенности:** Индекс всегда хранится локально на одном сервере и не может быть распределен на несколько узлов "из коробки". Это ограничивает горизонтальное масштабирование и отказоустойчивость.

- **Ресурсы при записи:** Процесс индексации (особенно коммит больших изменений) может быть довольно ресурсоемким и медленным. Для часто обновляемых индексов это может создать проблемы.

- **Сообщество и развитие:** Проект в основном поддерживается одним автором (Matt Chaput), и его развитие идет не так активно, как у крупных корпоративных продуктов. Выпуски новых версий могут быть нерегулярными.

- **Отсутствие встроенного UI:** Whoosh предоставляет только бэкенд для поиска. Для создания пользовательского интерфейса (поисковой строки, отображения результатов) нужно писать код самостоятельно или интегрировать с веб-фреймворками.

- **Ограниченная поддержка кластеризации и анализа:** В отличие от Elasticsearch, Whoosh не предоставляет продвинутых возможностей агрегации данных и статистического анализа.